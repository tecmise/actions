# üìä Relat√≥rio de Escaneamento de Diret√≥rio

**Data de Gera√ß√£o:** 18/11/2025 10:05:16  
**Diret√≥rio Base:** `.`  

## ‚öôÔ∏è Configura√ß√µes Utilizadas

- **Pastas Ignoradas:** Nenhuma
- **Extens√µes Ignoradas:** Nenhuma
- **Arquivo de Sa√≠da:** `result.txt`

## üìÅ Arquivos Encontrados

**5 Arquivos**  
**1 Pastas**

### üìà Resumo por Extens√£o

| Extens√£o | Quantidade | Tamanho Total |
|----------|------------|---------------|
| `.tf` | 5 | 7.4 KB |

**Tamanho Total:** 7.4 KB

### üìã Lista Detalhada

#### üìÇ Pasta `./(raiz)`

**1. 01-variable.tf**

- üìç **Caminho:** `01-variable.tf`
- üìè **Tamanho:** 2.4 KB

```tf
variable "application_name" {
  type = string
}

variable "region" {
  type = string
}

variable "cluster_id" {
  type = string
}


variable "cpu" {
  type = number
  default = 512
}

variable "memory" {
  type = number
  default = 1024
}


variable network_mode {
  type = string
  default = "awsvpc"
}


variable "desired_count" {
  type = number
  default = 1
}

variable "launch_type" {
  type = string
  default = null
}

variable "requires_compatibilities" {
  type = list(string)
  default = ["FARGATE"]
}

variable "family_name" {
  type = string
}

variable "network_configuration" {
  type = list(object({
    subnets         = list(string)
    security_groups = list(string)
    assign_public_ip = optional(bool, false)
  }))
}

variable "load_balancer" {
  type = list(object({
     target_group_arn = string
     container_name   = string
     container_port   = number
  }))
}

variable "task_policy_arns" {
  type = list(string)
  default = []
}

variable "containers_definitions" {
  type = list(object({
    name         = string
    image        = string
    cpu          = optional(number, null)
    memoryReservation       = optional(number, null)
    essential    = optional(bool, true)
    restart_policy      = optional(bool, true)
    portMappings = list(object({
      containerPort = number
      hostPort      = number
      protocol      = string
    }))
    environment = list(object({
      name  = string
      value = string
    }))

    resourceRequirements = list(object({
      type  = string
      value = string
    }))

    healthCheck = optional(object({
      command     = list(string)
      interval    = number
      timeout     = number
      retries     = number
      startPeriod = number
    }), null)


... (arquivo truncado - mostrando apenas 100 linhas de 144 total)
```

**2. 02-cloudwatch.tf**

- üìç **Caminho:** `02-cloudwatch.tf`
- üìè **Tamanho:** 127.0 B

```tf
resource "aws_cloudwatch_log_group" "default" {
  name              = "/ecs/${var.application_name}"
  retention_in_days = 7
}
```

**3. 03-iam.tf**

- üìç **Caminho:** `03-iam.tf`
- üìè **Tamanho:** 1.0 KB

```tf
resource "aws_iam_role" "task-execution" {
  name = "execution-${var.application_name}"
  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = "sts:AssumeRole",
        Effect = "Allow",
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      },
    ]
  })
}

resource "aws_iam_role_policy_attachment" "task_execution" {
  count = var.aws_iam_policy_task_execution_arn != "" ? 1 : 0
  policy_arn = var.aws_iam_policy_task_execution_arn
  role       = aws_iam_role.task-execution.id
}

resource "aws_iam_role" "service" {
  name = "task-${var.application_name}"
  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = "sts:AssumeRole",
        Effect = "Allow",
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      },
    ]
  })
}

resource aws_iam_role_policy_attachment tasks {
  count      = length(var.task_policy_arns)
  policy_arn = var.task_policy_arns[count.index]
  role       = aws_iam_role.service.id
}
```

**4. 04-service.tf**

- üìç **Caminho:** `04-service.tf`
- üìè **Tamanho:** 3.3 KB

```tf
resource "aws_ecs_task_definition" "server" {
  family                   = var.family_name
  network_mode             = var.network_mode
  requires_compatibilities = var.requires_compatibilities
  cpu                      = var.cpu
  memory                   = var.memory
  execution_role_arn       = aws_iam_role.task-execution.arn
  task_role_arn            = aws_iam_role.service.arn
  container_definitions    = jsonencode(flatten([
    for index, value in var.containers_definitions : {
      name         = value.name
      image        = value.image
      essential    = value.essential
      cpu          = value.cpu
      memoryReservation       = value.memoryReservation
      resourceRequirements = value.resourceRequirements
      restartPolicy = {
        enabled = value.restart_policy
      }
      portMappings = value.portMappings
      environment = value.environment
      healthCheck = lookup(value, "healthCheck", null)
      logConfiguration = {
        logDriver = "awslogs",
        options   = {
          "awslogs-group"         = aws_cloudwatch_log_group.default.name,
          "awslogs-region"        = var.region,
          "awslogs-stream-prefix" = var.application_name
        }
      }
    }
  ]))

}

resource "aws_ecs_service" "server" {
  name             = var.application_name
  cluster          = var.cluster_id
  task_definition  = aws_ecs_task_definition.server.arn
  desired_count    = var.desired_count
  launch_type      = var.launch_type
  platform_version = var.launch_type == "FARGATE" ? "LATEST" : null
  enable_execute_command = true

  dynamic "service_connect_configuration" {
    for_each = toset(var.service_connect_configuration)
    content {
      enabled = service_connect_configuration.value.enabled
      namespace = service_connect_configuration.value.namespace

      service {
        port_name = service_connect_configuration.value.service["port_name"]
        discovery_name = service_connect_configuration.value.service["discovery_name"]

        dynamic "client_alias" {
          for_each = service_connect_configuration.value.service["client_alias"]
          content {
            port = client_alias.value["port"]
            dns_name = client_alias.value["dns_name"]
          }
        }
      }
    }
  }

  dynamic "service_registries" {
    for_each = toset(var.service_registries)
    content {
      registry_arn = service_registries.value.registry_arn
    }
  }



  dynamic "capacity_provider_strategy" {
    for_each = toset(var.capacity_provider_strategy)
    content {
      capacity_provider = capacity_provider_strategy.value.capacity_provider
      weight = capacity_provider_strategy.value.weight
      base = capacity_provider_strategy.value.base
    }
  }

  dynamic "network_configuration" {
    for_each = toset(var.network_configuration)
    content {
      subnets         = network_configuration.value.subnets
      security_groups = network_configuration.value.security_groups
      assign_public_ip = network_configuration.value.assign_public_ip
    }
  }

  dynamic "load_balancer" {
    for_each = toset(var.load_balancer)
    content {
     target_group_arn = load_balancer.value.target_group_arn
     container_name   = load_balancer.value.container_name
     container_port   = load_balancer.value.container_port
    }
  }


... (arquivo truncado - mostrando apenas 100 linhas de 105 total)
```

**5. 05-output.tf**

- üìç **Caminho:** `05-output.tf`
- üìè **Tamanho:** 528.0 B

```tf
output "ecs_task_definition_arn" {
  value = aws_ecs_task_definition.server
}

output "ecs_service_name" {
  value = aws_ecs_service.server
}

output "cloudwatch_log_group_name" {
  value = aws_cloudwatch_log_group.default
}

output "iam_task_execution_role_arn" {
  value = aws_iam_role.task-execution.arn
}

output "iam_service_role_arn" {
  value = aws_iam_role.service.arn
}

output "iam_task_execution_role_id" {
  value = aws_iam_role.task-execution.id
}

output "iam_service_role_id" {
  value = aws_iam_role.service.id
}
```

