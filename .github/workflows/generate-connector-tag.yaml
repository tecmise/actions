name: "Publish Version"
on:
  workflow_call:
    secrets:
      DISCORD_NOTIFIER_URL:
        required: true

jobs:

  loading_pr_data:
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.merged }}
    outputs:
      result: ${{ steps.keyword.outputs.result }}
    steps:
      - name: Checking out the repository
        id: keyword
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const prNumber = context.payload.pull_request.number;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });

            reviews.sort((a, b) =>
              new Date(b.submitted_at) - new Date(a.submitted_at)
            );

            let encontrou = false;
            for (const review of reviews) {
              const body = (review.body || '').toLowerCase();
              if (body.includes('major')) {
                return "major";
              }
              if (body.includes('minor')) {
                return "minor";
              }
            }
            return "patch";
      - name: Next Version
        run: |
          echo "Versionament: ${{ steps.keyword.outputs.result }}"

      - name: Checking versionament
        id: versionament
        uses: tecmise/actions/.github/actions/versionament@main

      - name: Show versionament
        run: |
          echo "Major: ${{ steps.versionament.outputs.major }}"
          echo "Minor: ${{ steps.versionament.outputs.minor }}"
          echo "Patch: ${{ steps.versionament.outputs.patch }}"

#
#  patch:
#    name: "Patch Version"
#    runs-on: ubuntu-latest
#    needs: loading_pr_data
#    if: ${{ needs.loading_pr_data.outputs.result == 'patch'}}
#    steps:
#      - name: Checkout completo com tags
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0
#          fetch-tags: true
#
#      - name: Create & Push Patch Tag
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#        run: |
#          git config user.name "GitHub Actions"
#          git config user.email "actions@github.com"
#          git fetch --tags
#          git checkout master
#          git pull origin master
#
#          # Pega última tag no formato vX.Y.Z
#          LATEST_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0)
#          echo "Última tag: $LATEST_TAG"
#
#          # Se não houver nenhuma, inicia em 0.0.0
#          if [ -z "$LATEST_TAG" ]; then
#            MAJOR=0; MINOR=0; PATCH=0
#          else
#            VERSION=${LATEST_TAG#v}
#            IFS='.' read MAJOR MINOR PATCH <<< "$VERSION"
#          fi
#
#          # Incrementa somente o patch
#          PATCH=$((PATCH + 1))
#          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
#          echo "Criando tag $NEW_TAG"
#
#          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
#          git push origin "$NEW_TAG"
#
#  minor:
#    name: "Minor Version"
#    runs-on: ubuntu-latest
#    needs: loading_pr_data
#    if: ${{ needs.loading_pr_data.outputs.result == 'minor'}}
#    steps:
#      - name: Checkout completo com tags
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0    # Busca todo o histórico
#          fetch-tags: true  # Garante que as tags sejam trazidas
#
#      - name: Create & Push Patch Tag
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#        run: |
#          git config user.name "GitHub Actions"
#          git config user.email "actions@github.com"
#          git fetch --tags
#          git checkout master
#          git pull origin master
#
#          # Pega última tag no formato vX.Y.Z
#          LATEST_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0)
#          echo "Última tag: $LATEST_TAG"
#
#          # Se não houver nenhuma, inicia em 0.0.0
#          if [ -z "$LATEST_TAG" ]; then
#            MAJOR=0; MINOR=0; PATCH=0
#          else
#            VERSION=${LATEST_TAG#v}
#            IFS='.' read MAJOR MINOR PATCH <<< "$VERSION"
#          fi
#
#          # Incrementa somente o patch
#          PATCH=$((PATCH + 1))
#          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
#          echo "Criando tag $NEW_TAG"
#
#          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
#          git push origin "$NEW_TAG"
#  major:
#    name: "Major Version"
#    runs-on: ubuntu-latest
#    needs: loading_pr_data
#    if: ${{ needs.loading_pr_data.outputs.result == 'major'}}
#    steps:
#      - name: Checkout completo com tags
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0    # Busca todo o histórico
#          fetch-tags: true  # Garante que as tags sejam trazidas
#
#      - name: Create & Push Patch Tag
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#        run: |
#          git config user.name "GitHub Actions"
#          git config user.email "actions@github.com"
#          git fetch --tags
#          git checkout master
#          git pull origin master
#
#          # Pega última tag no formato vX.Y.Z
#          LATEST_TAG=$(git describe --tags --match "v[0-9]*" --abbrev=0)
#          echo "Última tag: $LATEST_TAG"
#
#          # Se não houver nenhuma, inicia em 0.0.0
#          if [ -z "$LATEST_TAG" ]; then
#            MAJOR=0; MINOR=0; PATCH=0
#          else
#            VERSION=${LATEST_TAG#v}
#            IFS='.' read MAJOR MINOR PATCH <<< "$VERSION"
#          fi
#
#          # Incrementa somente o patch
#          PATCH=$((PATCH + 1))
#          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
#          echo "Criando tag $NEW_TAG"
#
#          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
#          git push origin "$NEW_TAG"